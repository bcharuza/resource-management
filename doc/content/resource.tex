\section{Abstrakcja zasobu}\label{sec:resource}
Po wielokrotnym napotkaniu przedstawionego wcześniej kodu, zacząłem myśleć jak uprościć życie sobie, i towarzyszom niedoli. Jak sprawić by użytkownik kodu nie musiał zastanawiać się jak, gdzie i po co blokować zasób i pogramować szęśliwie jak wcześniej w stylu jednowątkowym bez trosk i zmartwień wielowątkowej dżungli.

\paragraph{Resource<T>}
W poprzednim kodzie błędnie ustalano zakresy muteksów. Zacząłem więc od silnego związania zasobu z zewnętrznym dla niego muteksem. Tak zaprojektowany wrapper sam ściągałby z użytkownika blokowanie i zwalnianie muteksu. Dobrze byłoby też jasno zaznaczyć obszar sekcji krytycznej, by użytkownik szablonu wiedział gdzie musi się pilnować. Aby zagwarantować zwalnianie muteksu po wyrzuceniu wyjątku użyto \code{lock\_guard<>}. 
\includeCpp{../../examples/resource}{Resource.hpp}
Klasa jest prosta i skupia się wyłącznie na zajmowaniu zasobu. Inicjacja wrapperu odbywa się transparentnie dla obiektu i nie zakłada dodatkowych zabezpieczeń - wtórca obiektu musi dopilnować, że inicjacja nie będzie przebiegała na globalnej stercie. Dostęp do chronionego obiektu odbywa się za pomocą wizytatora poprzez metodę \code{critical\_section()}. Muteks jest blokowany w przed wejściem do sekcji krytycznej i automatycznie zwalniany po jej opuszczeniu.
\code{Resource<T>} jest nieprzenośny i niekopiowalny - jest to celowe ograniczenie stawiane na użytkownika by wymóc umieszczanie zasobów w statycznych lokalizacjach i by ograniczyć ilość utrzymywanych do niego odniesień.

\paragraph{CfgReader}
\code{CfgReader} zmodyfikowano by zamiast pól statycznych posiadał pola lokalne dla instancji. Po usunięciu pól statycznych klasa będzie teraz prostsza w testowaniu. Dostęp do globalnej instancji odbywa się przez \code{getGlobalCfg()}. Poprawna inicjacja jest gwarantowana przez standard.
\includeCpp{../../examples/resource}{CfgReader.hpp}
\includeCpp{../../examples/resource}{CfgReader.cpp}

\paragraph{MsgHandler}
Nowy wrapper ma też zastosowanie w klasie \code{MsgHandler}. Zastosowanie szablonu \code{Resource<>} uporządkuje też błędne zakresy i wewnętrzne zakleszczenia.
\includeCpp{../../examples/resource}{MessageHandler.hpp}
\includeCpp{../../examples/resource}{MessageHandler.cpp}
Należy zauważyć że \code{MQClient} nie używa już muteksu - jest on już niepotrzebny gdyż to czy instancja ma służyć do użytku wielowątkowego jest definiowane przez umieszczenie jej wewnątrz \code{Resource<>}. Następną ważną różnicą jest zmiana metody \code{MsgHandler::setClient()} - instancja zasobu nie jest już upubliczniana poza \code{MsgHandler} - klasa jest właścicielem wszystkich zawieranych przez siebie zasobów.

Kod metod klasy \code{MsgHandler} wydaje się czystszy i udało się usunąć zakleszczenia. Zasada jest prosta - pobieramy zasób - wykonujemy minimalny zestaw instrukcji w sekcji krytycznej i wracamy.
Sekcje krytyczne bazują na mechanizmie funkcji lambda wprowadzonych w \Cpp{}11 - działają one jak obiekty funkcyjne i mają prosty format: \code{[<zmienne zewnętrzne>](auto\&~x)\{<zestaw~instrukcji>\}}. Wynik return można przekazać poza sekcję krytyczną poprzez przypisanie wyniku do zmiennej.

Wszystkie funkcje \code{MsgHandler} są teraz statyczne i tworzenie instancji jest niepotrzebne. Okazuje się że Sama klasa \code{MsgHandler} jest niepotrzebna i można ją rozbić na niezależne funkcje globalne. Alternatywnie można zezwolić by każda instancja posiadała lokalne pola \code{MQClient}, \code{MsgQueue}, czy listę subskrybcji - wtedy należy ściągnąć wrappery \code{Resource<>} z lokalnych pól instancji i nałożyć go na współdzielone instancje \code{MsgHandler}.

Funkcja \code{accessClient()} pokazuje jak w prosty sposób zrealizować opóźnioną inicjację - wystarczy stworzyć zasób dla \code{unique\_ptr}.

\paragraph{main}
Main został lekko zmieniony - warto zwrócić uwagę jak inicjowany jest teraz \code{CfgReader}. Zamiast ustawiania globalnych pól - inicjowany jest lokalny obiekt, a następnie jest kopiowany do przestrzeni współdzielonej. W ten sposób zajmujemy tylko jeden zasób jednocześnie - pierw plik, a później obiekt współdzielony. 
\includeCpp{../../examples/resource}{main.cpp}
Aplikacja jest teraz stabilna - nie ma wyścigów danych. Nie ma błędów kolejności inicjacji zmiennych statycznych. Klasa \code{MsgHandler} nadal pozwala na wyścigi związane z nieatomowym interfacem. \code{trace()} nadal wykorzystuje mechanizmy C, co powoduje błędną interpretację danych podczas wyświatlenia konfiguracji.

Kod tak jak poprzednio pos kompilowaniu mozna uruchomić za pomocą \inlineBash{ctest resource-test1} (lub \inlineBash{<resource-binary> test1.cfg} gdy kompilujemy bez CMake).

\paragraph{podsumowanie dla klasy Resource<>}
W dostępie do zasobów należy uwzględnić następujące kwestie:
\begin{itemize}
\item Mechanizm \code{critical\_section()} zwalnia z użytkownika obowiązek dbania o zarządzanie dostępem.
\item \code{Resource<>} wiąże zasób i blokadę.
\item \code{Resource<>} powinien być przechowywany jako statyczna zmienna w globalnej funkcji dostępowej.
\item \code{Resource<unique\_ptr<>{}>} daje wsparcie dla opóźnionej inicjacji.
\item \code{Resource<>} ułatwia kontrolę zasięgu sekcji krytycznych.
\end{itemize}
