\section{Opis problemu}\label{sec:problem-desc}
Za punkt wyjścia przyjmiemy spreparowany omówiony poniżej, które można znaleść w katalogu \code{./examples/problem} \note{projektu}{\link{https://github.com/bcharuza/resource-management/}}. Przykłady są syntezą kodu produkcyjnego zastanego w kilku projektach z którymi pracowałem.

\paragraph{main}
Main wskazuje przykładowy kod programu. Dobrym ćwiczeniem dla czytelnika byłoby wskazanie kilku poważnych błędów zwązanych z nieprawidłowym użyciem przedstawionych uprzednio struktur.
\includeCpp{../../examples/problem}{main.cpp}
Podstawowym problemem tego kodu jest to że uprzednie struktury zezwoliły ich użytkownikowi na ich nieprawidłowe użycie. Interface jest nieprawidłowo skonstruowany. Co gorsze po wykonaniu pierwszego testu za pomocą \inlineBash{ctest -R problem-test1} (lub \inlineBash{<problem-binary> test1.cfg} gdy kompilujemy bez CMake) aplikacja się zawiesza.
\includeText{../../tests/}{test1.cfg}
\includeText{../../tests/}{test1-in.txt}
Zawieszenie się aplikacji jest spowodowane podwójnym zajęciem muteksu klasy. Każda z metod zajmuje muteks instancji by zablokować klasę. W przypadku gdy \code{std::mutex} jest zajmowany poraz 2 w tym samym wątku następuje zakleszczenie. Jest to znacznie trudniejsze do wykrycia gdy muteks jest statyczny, lub co gorsze - współdzielony w pamięci wolnej. Można to rozwiązać zamieniając \code{std::mutex} na \code{std::recursive\_mutex} \note{jednak jego użycie uznaje się za symptom źle zaprojektowanego współdzielenia zasobów}{Anthony Williams ,,Język \Cpp{} i przetwarzanie współbieżne w akcji''} - w skrócie jeśli pozwalamy na zakleszczenie na pojedynczym muteksie, prawdopodobnie kod jest też wrażliwy na zakleszczenie w scenariuszach z wieloma muteksami, a sekcje krytyczne są zbyt rozbudowane.

Podwójne blokowanie można naprawić przez zamianę definicji \inlineCpp{using mtx\_t = std::mutex} na \inlineCpp{using mtx\_t = std::recursive\_mutex} w pliku \code{MessageHandler.hpp}. Kod nadal będzie posiadał wyścig wewnątrz \code{ping\_race()}, ale logi początkowe będą możliwe do odczytania. Wyścig w \code{pingrace()} jest spowodowany umieszczeniem muteksu i zasobów w różnych zakresach - muteks jest lokalny dla instancji, zaś zasoby są współdzielone przez obiekty.
Po ponownym uruchomieniu testu otrzymamy następujący wynik:
\begin{itemize}
\item \code{test1-out.txt}: pusty lub wypełniony tylko początkowymi wiadomościami. Nie widać tego w kodzie - jednak jak opisano wcześniej, globalna instancja \code{s\_handler} i lokalna wątku \code{handler1} wpływają na siebie.
\item \code{log}: zawiera wiadomość diagnostyczną i zdublowane wiadomości które miały trafić do \code{test1-out.txt}. Dublowanie wiadomości jest także spowodowane tym że \code{sender} został 2-krotnie zasubskrybowany we współdzielonej przestrzeni pomimo że wygląda jakby był zasubskrybowany dla obiektu.
\item \code{konsola}: Kolejne błędy w kodzie można dostrzec po sprawdzeniu wyjścia konsoli.
  \begin{itemize}
  \item \code{((null)[140624307808064])[INFO] Initialized MsgHandler}: trace został wywołany zanim zainicjowano zmienną statyczną \code{CfgReader::s\_sysName}.
    \item \code{(Sys1[140250092123968])[INFO] msgInput:  śčĄţ} Błędy są spowodowane nieprzekazaniem właściwego typu do trace. Kompilator nie był w stanie tego wychwycić.
  \end{itemize}
\end{itemize}

\code{main.cpp} posiada jeszcze jeden błąd trudniejszy do uchwycenia - wyścig instrukcji podczas usuwania elementów kolejki - pomiędzy wywołaniem \code{top()} i \code{remove()} inny proces może też wykonać \code{set()} a wtedy \code{remove()} spowoduje usunięcie wiadomości niebędącej już na szczycie. Jest to spowodowane otwarciem nieformalnej traksakcji -- założeniem że dany proces musi wykonać sekwencję operacji by zmienić stan obiektu -- operacje nie są atomowe.

Na koniec stawiam do przemyślenia kwestie użycia wskaźników w kodzie wielowątkowym:
\begin{itemize}
\item Co stanie się po przekazaniu tego samego \code{MessagePtr} do 2 różnych instancji \code{MsgQueue}? czy będzie prawidłowo usunięty? Czy występuje ryzyko podwójnego usunięcia? Czy zliczanie referencji w \code{shared\_ptr} jest bezpieczne? czy jest to wydajne?
\item Co stanie się gdy kilka wątków zacznie modyfikować wiadomość udostępnianą przez \code{MsgQueue}?
\item Czy podobne kwestie są aktualne dla \code{weak\_ptr} i \code{unique\_ptr}
\end{itemize}

\paragraph{podsumowanie problemu}
W dostępie do zasobów należy uwzględnić następujące kwestie:
\begin{itemize}
\item Funkcje biblioteczne i systemowe niewspierające wielowątkowości.
\item Inicjację zasobu.
\item Odległość zasobu i blokady.
\item Wskaźniki i referencje.
\item Głębokość sekcji krytycznych.
\item Atomowość sekcji krytycznych.
\item Zachowanie spójność zasobu między sekcjami krytycznymi.
\item Unikanie wywołania zewnętrznego kodu wewnątrz sekcji krytycznych.
\end{itemize}
